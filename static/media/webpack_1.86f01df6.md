# [TIL_Module] Module, Bundler 그리고...#1

## 시작하며

포트폴리오에 올릴 작업물을 정리하면서 처음으로 웹팩을 제대로 공부해보기 시작했다. HTML에 `<script>` 태그를 삽입해 JavaScript 파일을 순서대로 로드하는 간단한 방식에서부터, `export`, `import` 전역 객체로부터 각 모듈을 주고 받는 방식까지 알게 모르게 또 자연스럽게 모듈 시스템을 사용해왔지만, 정작 번들러니 모듈이니 하는 컨셉에 대한 이해는 부족했었다. 그러다 웹팩의 어마무시한 설정 파일에서 1차로 좌절하고, 정말로 이럼에도 불구하고 webpack이 그렇게 대체 불가한 번들러인지, 다른 건 없는지, 애시당초 이 모듈은 어쩌다가 생긴 것인지 등 꼬리에 꼬리를 무는 의문을 해결해야 해서 이 시리즈를 시작했다. 

## 태초의 JavaScript에서의 모듈이 가진 문제
HTML에 순서대로 삽입되는 간단한 방식의 JavaScript라 할지라도 모듈이 로드되며 전역 변수가 덮어쓰이곤 하는 문제가 발생했다. A 파일, B 파일 순으로 로드되는 순서라고 할 떄, A라는 파일에서 쓰인 전역 변수 a가 B라는 파일의 전역 변수 a로 재정의되어 개발자가 의도한대로 파일이 동작하지 않는 식이었다. 당연히 변수의 이름, 모듈끼리의 충돌을 피하기 위해 많은 시간과 노력이 필요했으리라.

## CommonJS, AMD 그리고 UMD
JavaScript가 등장하고 꾸준히 인기를 끌었다. 2008년에는 Google의 V8 엔진이 등장해 브라우저 밖에서 JavaScript를 사용하는 것에 대한 아이디어가 많이 생겨났고, 모듈화를 표준화해야 한다는 생각도 강해졌다. 모듈화는 아래 세 가지를 컨셉으로 가진다. 

- Scope : 모든 모듈은 자신만의 독립적인 실행 영역이 있어야 한다. 
- Definition : 모듈 정의는 exports 객체를 이용한다. 
- Usage : 모듈 사용은 Require 함수를 이용한다. 

각 모듈은 독립적이고 지역적인 파일 스코프를 가지므로, 기존 JavaScript에서 전역 변수가 겹치던 문제를 해소할 수 있어 변수의 활용이 훨씬 쉬워진다. 만일 모듈 간 정보를 공유하기 위해서는 exports, require를 통하면 된다.

### 동기적으로 모듈을 호출하기 - CommonJS
브라우저 밖 JavaScript를 상상했을 때, 가령 Server-side에서라면 모든 모듈이 제공되어 있다는 환경을 가정한다. 이를 동기적으로 모듈을 호출하는 방식이라 한다.

동기적 모듈 호출 방식은 아래와 같은 특징을 가진다. 
- `require`, `exports`의 키워드 활용
- 비동기 방식보다는 느리다. 
- Tree Shaking(임포트는 되었지만, 실제로는 사용하지 않는 코드를 분석하고 삭제하는 등 코드를 최적화하는 기술)이 어렵다.
- 순환참조에 취약하다

초기 모듈 시스템을 채택하는 과정에서 JavaScript 런타임인 Node.js는 CommonJS의 명세를 따랐지만, 시간이 지나며 브라우저를 고려하지 않는 동기적 모듈 방식의 한계가 있었고, CommonJS 모듈 방식을 브라우저에서도 사용하기 위해 빌드 도구인 Browserify가 생겼다. 

### 비동기적으로 모듈을 호출하기 - AMD
브라우저에서라면 서로 의존 관계에 있는 모듈 중 일부가 미처 다운받아지지 않은 상황이라면 제대로 동작하지 않는다는 단점이 있었다. 이런 단점을 극복하기 위해 AMD(Asynchronous Module Definition)는 CommonJS에서 분화해 브라우저 내에서의 실행에 초점을 맞춰 활동했다. 즉, 필요한 모듈을 네트워크를 이용해 내려받아야 하는 브라우저 환경에서도 모듈을 사용할 수 있도록 표준화하고자 했다. 

```js
// module definition
define([
    'jquery', 'underscore', // 의존 모듈은 배열로 나열된다. 
], function($, _) { // 의존 모듈은 순서대로 매개변수에 담긴다.
    return {
                // 외부에 노출할 함수만 반환한다. 
    }
}
)

// module usage
require([
    ...
    // 사용할 모듈을 배열로 나열한다. 
], function(..) {
    // 사용할 모듈이 순서대로 매개변수에 담긴다. 
})
```
비동기적 모듈 호출 방법은 이런 특징을 지닌다. 
- 동기적 방식에 비해 조금 더 복잡한 문법
- 비동기적으로 호출하므로 성능면에서 개선
- 브라우저, 서버 사이드 모두 호환 가능

이런 특징을 가진 AMD 명세로 구현된 대표적인 모듈 로더 라이브러리에는 RequireJS가 있었다. 

### UMD 
규격이 통일되어 있지 않으니, 호환성 문제를 해결하기 위해 UMD(Universal Module Definition) 패턴이 생겨났다. CommonJS와 AMD 방식을 모두 호환할 수 있도록 조건문으로 분기하고, 이를 팩토리 패턴으로 구현하는 것이다. 

```js
(function (root, factory) {
    if (typeof define === "function" && define.amd) { // AMD 방식
        define(["jquery", "underscore"], factory);
    } else if (typeof exports === "object") { // CommonJS 방식
        module.exports = factory(require("jqeury"), require("underscore"));
    } else {
        root.foo = factory(root.$, root._);
    }
}) (this, function ($, _) { // Module Definition
    var foo = {
        // ..
    }
    return foo;
})
```

- 문법이 난해함
- 하지만 CommonJS와 AMD를 모두 호환한다. 
- `window` 객체를 통해 전역적으로도 접근 가능하다. 
- 따라서 라이브러리를 만들 때 많이 사용되는 패턴으로 자리잡았다. 

## ES6 Module
하지만 UMD도 완전한 해결책은 아니었다. 오직 CommonJS와 AMD 방식 사이의 호환성만을 고려한 설계였기 때문이다. JavaScript 생태계의 표준 역할을 할 모듈 시스템이 필요해졌다. 

2015년, ES6라고 불리는 ECMAScript 6에서 JavaScript 표준 모듈 시스템이 명세되었다. (ES6 Module)

```js
import foo from 'bar';
export default qux;
```

- 동기/비동기를 모두 지원한다. 
- 문법이 간단하다. 
- CommonJS와 다르게 실제 객체/함수를 바인딩하므로 순환 참조 관리가 편하다. 
- 정적 분석 (Static Analyze : 코드를 실행하지 않더라도 분석이 가능함.) 이 가능하므로, Tree Shaking이 쉬워졌다. 
- 그러나 구형 브라우저에서는 제대로 동작하지 않는다. (최신 문법인 탓)

## 트랜스파일러(Transpiler)
ES6에서 JavaScript 표준 문법을 정의했음에도, ES6 문법을 구형 브라우저에서 사용하지 못하니, SystemJS 같은 라이브러리에 의존해야 하는 상황이 왔다. 그래서 트랜스파일러가 등장하게 되었다. 한 번의 컴파일로, 구형 브라우저에서도 동작하는 JavaScript 코드가 나오도록 하는 것이다. 

대표적인 트랜스파일러로는 바벨(Babel)이 있다. 개발 시에는 최신 문법의 JavaScript를 사용하고, 이후 바벨로 컴파일만 하면 구형 브라우저에서도 호환이 된다. 

## 슈퍼셋(Superset)
다른 방법으로는 CoffeeScript, TypeScript 같은 슈퍼셋(Superset) 언어를 사용하는 것이 있다. 

## 태스크 러너(TaskRunner)
스코프가 구분되는 모듈을 만들기 위해 이러한 노력들이 있었다. 그런데 왜 스코프가 구분되는 모듈을 만들어야 했을까? 여러 모듈을 조합하는 방식을 통해 중복된 코드는 줄이고, 생산성과 성능이 뛰어난 애플리케이션을 만들기 위함이었다. 

그렇기 위해서는 개발 과정에서 코드를 작성하고, 컨벤션을 유지하기 위해 린트를 사용하고, Sass나 TypeScript 같은 전처리가 필요한 언어를 컴파일하고, 소스 코드를 축소하고, 파일을 하나로 묶는 일련의 과정이 동반되는 것이다. 이런 과정을 반복되어 개발자의 생산성을 떨어뜨리니 이를 자동화하는 도구의 필요성이 대두되었고, 이것이 태스크 러너가 등장하게 된 배경이다. 

이런 빌드를 위한 태스크 러너의 일부였던 번들을 좀 더 전문화한 영역으로 발전시킨 것이 '모듈 번들러'이다. 

## 모듈 번들러(Module Bundler)
모듈 번들러는 JavaScript 모듈을 브라우저에서 실행할 수 있는 단일 JavaScript 파일로 번들링하는 데 사용되는 프론트엔드 개발 도구이다. 

- 모듈 로더 : 런타임에 모듈을 가져오기 위한 목적.
- 모듈 번들러 : 코드를 프로덕션 환경에서 사용하기 위한 목적을 지닌다. 빌드 시 모듈을 묶어 단일 번들 파일을 만들기 위함이니, 런타임에서 추가적인 로드가 불필요하다. 

모듈 번들러는 크게 세 가지 이유로 사용된다. 
- 모든 브라우저가 모듈 시스템을 완전하게 지원하는 것이 아니다. 
- 코드의 종속성 관계를 관리하는 데 도움이 된다. 
- 종속성의 순서, 이미지, CSS assets를 로드하는 데 도움이 된다. 

그러나 이런 목적을 넘어 현재 모듈 번들러는 사용하지 않는 코드의 제거 같은 최적화 작업도 겸한다. 이제 번들러 자체가 제공하는 각종 플러그인으로 해결할 수 있는 상황이 넓어지다보니 별도의 태스크 러너나 최적화 도구가 대체되었다. 

## 현대의 모듈 번들러 비교
*Webpack*
- 생태계가 풍부하다, 안전성이 뛰어나다. 
- Third-party library 관리, CSS 전처리, 이미지 애셋 관리 등에서 뛰어나다. 
- 그러다보니 다른 번들러에 비해 설정이 많고 복잡한 편이다. 
- 웹팩이 제공하는 개발 서버가 뛰어나다. (Live Reloading, HMR-Hot Module Replacement 등)
- Tree Shaking이 지원된다. (단, CommonJS 방식으로 모듈을 로드한 부분을 ES6로 교체하는 등의 작업이 필요)
- 많은 서드파티를 필요로 하는 복잡한 애플리케이션일 때 추천됨.

*Rollup*
- ES6 모듈 형식으로 빌드 결과물을 출력할 수 있어, 이를 라이브러리나 패키지에 활용할 수 있다. 
- 코드 스플리팅에서 강하다. 중복 제거에 특화되어 있다.
- 파일의 해시 캐스캐이딩(Hash Cascading, 하나의 파일의 해시가 바뀌면 이를 참조한 파일의 해시도 알아서 바뀐다.)이 약하다. 
- 최소한의 서드 파티로 라이브러리를 개발하고자 할 때 추천됨.

*Parcel*
- Zero Config (별도의 설정 파일이 필요하지 않다. )
- Tree Shaking에 있어서도 강점을 보인다. ES6, CommonJS 모듈 모두에 대해 지원
- 트랜스파일에 대한 기본 제공을 지원한다.  
- 파셀은 항상 모든 모듈에서 Babel을 사용해 최신 JavaScript를 브라우저에서 지원하는 형식으로 컴파일한다. 
- 복잡한 설정을 피하고, 비교적 간단한 어플리케이션을 만들고자 할 때 파셀이 추천됨. 

# Reference
- [JavaScript 표준을 위한 움직임: CommonJS와 AMD](https://d2.naver.com/helloworld/12864)
- [JavaScript 번들러로 본 조선시대 붕당의 이해](https://wormwlrm.github.io/2020/08/12/History-of-JavaScript-Modules-and-Bundlers.html)